# -*- coding: utf-8 -*-
"""AdventOfCode-AmitParikh.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CModdhiA-Mb1BbgrS3Kj7P7jBTJp-nFq

Day 1
"""

## Open input file
input = open("InputDay1.txt")
data = [int(value) for value in input.read().splitlines()]

## Function to Loop through numbers and look for numbers that add to 2020 
def findNum(data):
  for x in data:
    for y in data:
      for z in data: 
        if (x + y + z == 2020):
          return (x*y*z)

## Call function 
print(findNum(data))
## Close file 
input.close()

"""Day 2"""

### PART 1 ###
## Open input file
input = open("InputDay2.txt")
data = [value for value in input.read().splitlines()]
valid = 0 
for line in data:
  splitDash = line.split("-")
  min = int(splitDash[0])
  splitWhite = splitDash[1].split(" ")
  max = int(splitWhite[0])
  char = splitWhite[1][0]
  string = splitWhite[2]
  count = string.count(char)
  if (count>=min and count<=max):
    valid += 1

print(valid)

### PART 2 ###
## Open input file
input = open("InputDay2.txt")
data = [value for value in input.read().splitlines()]
valid = 0 
for line in data:
  splitDash = line.split("-")
  firstIndex = int(splitDash[0])
  splitWhite = splitDash[1].split(" ")
  secondIndex = int(splitWhite[0])
  char = splitWhite[1][0]
  string = splitWhite[2]
  if ((string[firstIndex-1]==char or string[secondIndex-1]==char) and not (string[firstIndex-1]==char and string[secondIndex-1]==char)):
    valid +=1

print(valid)

"""Day 3"""

### Part 1 ###
## Open input file 
input = open("InputDay3.txt")
data = [value for value in input.read().splitlines()]
# Count how many trees are encountered
trees = 0
index = 0
notFirst = False 
for row in data:
  if (index>=len(row)):
    index = index % len(row)
  if (row[index]=="#" and notFirst):
    trees+=1
  index +=3
  if not notFirst:
    notFirst = True

print(trees)

### Part 2 ###
## Open input file 
input = open("InputDay3.txt")
data = [value for value in input.read().splitlines()]
def findTrees(data,rightIncrementor,downIncrementor):
  # Count how many trees are encountered
  trees = 0
  index = 0
  notFirst = False
  rowNum = 0
  for row in data:
    if (rowNum%downIncrementor==0):
      if (index>=len(row)):
        index = index % len(row)
      if (row[index]=="#" and rowNum>0):
        trees+=1
      index +=rightIncrementor
    rowNum += 1
  return trees

## Find trees for different slopes and multiply answers
slopes = [[1,1],[3,1],[5,1],[7,1],[1,2]]
multiple = 1
for slope in slopes:
  right = slope[0]
  down = slope[1]
  print(findTrees(data,right,down))
  multiple = multiple * findTrees(data,right,down)

print(multiple)

"""Day 4"""

### PART 1 ###
input = open("InputDay4.txt")
data = [value for value in input.read().split("\n\n")]

## Var to count valid passports
valid = 0
## Array to store passports with valid fields for part 2 
valid_fields = []
for passport in data:
  req_fields = ["byr","iyr","eyr","hgt","hcl","ecl","pid"]
  has_fields = []
  ## Check if passport has the 7 fields
  for field in req_fields:
    has_fields.append(field in passport)
  
  ## If has fields, increase valid count
  if (False not in has_fields):
    valid += 1
    valid_fields.append(passport)
print(valid)

### PART 2 ### 
import re 

## Keep track of valid entries
val = 0
sol = []
## valid_fields array gotten in part 1 
for passport in valid_fields:
  ## Check byr
  byr_index = passport.find("byr")
  byr = int(passport[byr_index+4:byr_index+8])
  
  if (byr>=1920 and byr<=2002):
    ## Check iyr
    iyr_index = passport.find("iyr")
    iyr = int(passport[iyr_index+4:iyr_index+8])
    
    if (iyr>=2010 and iyr<=2020):
      ## Check eyr
      eyr_index = passport.find("eyr")
      eyr = int(passport[eyr_index+4:eyr_index+8])
      
      if (eyr>=2020 and eyr<=2030):
        ## Check hgt
        hgt_check = False 
        hgt_index = passport.find("hgt")
        hgt_string = passport[hgt_index+4:hgt_index+9].strip()
        metric = hgt_string[len(hgt_string)-2:len(hgt_string)]
        hgt = int(hgt_string[0:len(hgt_string)-2])
        if (metric == "cm" and (hgt >=150 and hgt <=193)):
            hgt_check = True
        elif (metric == "in" and (hgt>=59 and hgt<=76)):
            hgt_check = True
        
        if (hgt_check):
          ## Check hcl
          hcl_index = passport.find("hcl")
          hcl = passport[hcl_index+4:hcl_index+11]
          match = bool(re.match("^#[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]",hcl))
          
          if (match):
            ##check ecl
            ecl_index = passport.find("ecl")
            ecl = passport[ecl_index+4:ecl_index+7]
            
            if (ecl == "amb" or ecl =="blu" or ecl == "brn" or ecl == "gry" or ecl == "grn" or ecl == "hzl" or ecl == "oth"):
              ## check pid 
              pid_index = passport.find("pid")
              pid = passport[pid_index+4:pid_index+13]
              
              if (pid.isnumeric()):
                 val+=1
                 sol.append(passport)

print(val)

"""Day 5"""

### PART 1 ###
input = open("InputDay5.txt")
data = [value for value in input.read().splitlines()]

highest = 0
seatIDarr= [] ## For part 2 
for seat in data:
  rows = [0,127]
  columns = [0,7]
  for char in seat:
    if char == "F":
      rows = [int(rows[0]),int(rows[1]-(rows[1]-rows[0])/2)]
    elif char == "B":
      rows = [int(rows[0]+((rows[1]-rows[0])/2))+1,int(rows[1])]
    elif char == "L":
      columns = [int(columns[0]),int(columns[1]-(columns[1]-columns[0])/2)]
    elif char == "R":
      columns = [int(columns[0]+((columns[1]-columns[0])/2))+1,int(columns[1])]
    
  #seat = (rows[0],columns[0])
  seatID = rows[0]*8 + columns[0]
  seatIDarr.append(seatID)
  if seatID > highest:
    highest = seatID
    
print(highest)

### PART 2 ### 
## Using seatIDarr from part 1 
seatIDarr.sort()

notFound = True
index = int(len(seatIDarr)/2)
val = seatIDarr[index]
lowVal = val
lowIndex = index
highVal = val
highIndex = index
while notFound:
  lowVal = lowVal - 1
  lowIndex -=1
  highVal += 1
  highIndex += 1 
  if (seatIDarr[lowIndex]!=lowVal):
    index = lowIndex
    val = lowVal
    notFound = False
  elif (seatIDarr[highIndex]!= highVal):
    index = highIndex
    val = highVal
    notFound = False

print(val)

"""Day 6"""

### PART 1 ### 
input = open("InputDay6.txt")
data = [value for value in input.read().split("\n\n")]

sum = 0 

for group in data:
  questions_set = set()
  changed = group.replace("\n","") ## Remove \n from string
  for question in changed:
    questions_set.add(question)
  sum += len(questions_set)
  
print(sum)

### PART 2 ###  
input = open("InputDay6.txt") 
data = [value for value in input.read().split("\n\n")]

## Remove the last new line from the last group as it will be empty. If not removed it will show up as an extra group member
data[len(data)-1] = data[len(data)-1][:-1]

sum = 0 

for group in data:
  group_members = group.count("\n") + 1
  changed = group.replace("\n","")
  repeated = set()
  for question in changed:
    if (changed.count(question)== group_members):
      repeated.add(question)
 
  sum += len(repeated)
print(sum)

"""Day 7"""

class Graph: 
  def __init__ (self,key):
    self.id = key
    self.contains = []
  
  def addContains (self,clr,num):
    self.contains.append([clr,num])
  
  def getID (self):
    return self.id
  def getContains (self):
    return self.contains
  
## Part 1 
def findColor(color_node,search_color,color_graph):
  
  if (color_node.getID()==search_color):
    return 1
  elif (len(color_node.getContains())==0):
    return 0
  else: 
    #print(color_node.getContains())
    for x in color_node.getContains():
      
      for y in color_graph:
        
        if (x[0] == y.getID()):
           if (findColor(y,search_color,color_graph)==1):
             return 1
           else:
             continue
  return 0

## Part 2 
def findBags(color_node,color_graph):
  if (len(color_node.getContains())==0):
    return 0
  else:
    sum = 0
    for x in color_node.getContains():
      for y in color_graph:
        if x[0]==y.getID():
          sum += int(x[1])*(1+findBags(y,color_graph))
          
    return sum

### PART 1 ### 
input = open("InputDay7.txt")
data = [value for value in input.read().splitlines()]
colors = []
for rules in data:
  words = rules.split()
  rule_color = words[0] + " " + words[1]

  words = words[4:]
  ## Remove anything that contains "bag"
  words = [ word for word in words if "bag" not in word ]
  graph = Graph(rule_color)
  
  for i in range(0,len(words),3):
   #print("Number " + words[i])
   if (words[i] == "no"):
     continue
   graph.addContains(words[i+1]+" "+words[i+2],words[i])
  colors.append(graph)

sum = 0
for color in colors:
  sum += findColor(color,"shiny gold",colors)
  

print(sum-1) ##Subtract one because we don't want to count when the shiny gold bag

### PART 2 ###
for color in colors:
  if ("shiny gold" == color.getID()):
    #print(findBags(color,colors))
    print(findBags(color,colors))

"""Day 8 """

### PART 1 ###
input = open("InputDay8.txt")
data = [value for value in input.read().splitlines()]


isVisited = [False for i in range(len(data))] ## Array to store which indexes have already been visited
accumulator_count = 0 ## Keep track of accumulator sum
index = 0 ## Which index we should visit
while not isVisited[index]:
  ## Mark index as visited
  isVisited[index] = True

  operation = data[index][0:3]
  argument = int(data[index][4:])
  
  if (operation == "acc"):
    accumulator_count += argument
    index +=1
  elif (operation =="jmp"):
    index += argument
  else: 
    ## Operation == "nop"
    index += 1
  
print(accumulator_count)

def find_repeat(modified_data):
  #print(modified_data[0])
  isVisited = [False for i in range(len(modified_data))] ## Array to store which indexes have already been visited
  accumulator_count = 0 ## Keep track of accumulator sum
  index = 0 ## Which index we should visit
  while not isVisited[index]:
    ## Mark index as visited
    isVisited[index] = True

    operation = modified_data[index][0:3]
    argument = int(modified_data[index][4:])
    
    if (operation == "acc"):
      accumulator_count += argument
      index +=1
    elif (operation =="jmp"):
      index += argument
    else: 
      ## Operation == "nop"
      index += 1
    #print(index,len(modified_data))
    if (index>=len(modified_data)):
      return True,accumulator_count

    elif (index<0):
      return False,0
  
  ## Loop occured - return False
  return False,0


input = open("InputDay8.txt")
data = [value for value in input.read().splitlines()]

index = 0

for line in data:
  operation = line[0:3]
  argument = line[4:]

  data_copy = data.copy()
  if (operation=="jmp"):
    data_copy[index] = "nop " + argument

    #print("1: "+ data_copy[index])
    
  elif (operation=="nop"):
    data_copy[index] = "jmp " + argument
    #print("2: "+data_copy[index])
  else:
    ## operation == "acc"
    index+=1
    continue

  #print("3: "+ data_copy[index])
  no_loop,acc = find_repeat(data_copy)
  if no_loop:
    print(acc)
    break
  

  index+=1

"""Day 9"""

### PART 1 ### 
input = open("InputDay9.txt")
data = [int(value) for value in input.read().splitlines()]

preamble = data[0:25]
remaining = data[25:]

def is_a_sum(num, preamble):
  for x in preamble:
    for y in preamble:
      if (x+y==num and x!=y):
        return True
  return False


index = 0
preamble_of_weakness = []
weakness = 0
for num in remaining:
  if (is_a_sum(num,preamble)):
    preamble[index % 25] = num
    index +=1
  else:
    print(num)
    weakness = num
    
    break

### PART 2 ### 

##'weakness' stores the weakness
weak_index = data.index(weakness)
arr_of_nums = data[0:weak_index]
for x in range(0,len(arr_of_nums)):
  sum = arr_of_nums[x]
  for y in range(x+1,len(arr_of_nums)):
    #print(x,y)
    if (sum<weakness):
      sum += arr_of_nums[y]
    elif (sum == weakness):
      cont_range = arr_of_nums[x:y]
      smallest,largest = min(cont_range),max(cont_range)
      print(smallest+largest)
      break
    else:
      #print("*** " + str(sum) + " is greater than " + str(weakness))
      break

"""Day 10"""

### PART 1 ### 
input = open("InputDay10.txt")

data = [int(value) for value in input.read().splitlines()]
data.append(max(data)+3)
data.sort()

one_difference_count = 0
three_difference_count = 0
voltage = 0
for adapter in data:
  difference = adapter - voltage

  if (difference == 1):
    one_difference_count += 1 
  elif (difference == 3):
    three_difference_count+=1

  voltage = adapter

print(one_difference_count*three_difference_count)

### PART 2 ### 
input = open("InputDay10.txt")
data = [int(value) for value in input.read().splitlines()]
data.sort()


poss = {0: 1} ## dictionary that stores number of ways to get to the 'key' for ex. there is 1 way to get to 0

for num in data:
    counter = 0
    for x in range(1, 4):
        if (num-x) in poss: ## the number of ways to get to a num is the sum of the num of ways to get to num-1, num-2, and num-3
            counter += poss[num-x]

    poss[num] = counter

print(poss[max(data)])

## Extra dynamic programming practice - fibonacci sum with dynamic programming

fib_dict = {0:0, 1:1}

def fib(num_to_solve):
  for num in range(2,num_to_solve+1):
    fib_dict[num] = fib_dict[num-1] + fib_dict[num-2]
  print(fib_dict[num_to_solve])

fib(20)

"""Day 11"""

### PART 1 ### 
from copy import deepcopy
input = open("InputDay11.txt")
data = [value for value in input.read().splitlines()]

## Create initial array 
seating_array = []
for row in data:
  seating_row = []
  for pos in row:
    seating_row.append(pos)
  seating_array.append(seating_row)


def findAdjacentSeats(x,y,arr):
  adjacent_seats = []
  if (x-1>=0):
    adjacent_seats.append((x-1,y))
  if (x+1<len(arr[y])):
    adjacent_seats.append((x+1,y))
  if (y-1>=0):
    adjacent_seats.append((x,y-1))
  if (y+1<len(arr)):
    adjacent_seats.append((x,y+1))
  if (x-1>=0 and y-1>=0):
    adjacent_seats.append((x-1,y-1))
  if (x+1<len(arr[y-1]) and y-1>=0):
    adjacent_seats.append((x+1,y-1))
  if (x-1>=0 and y+1<len(arr)):
    adjacent_seats.append((x-1,y+1))
  if (y+1<len(arr) and x+1<len(arr[y+1])):
    adjacent_seats.append((x+1,y+1))
  
  return adjacent_seats



## fix seats
chaos = True
while chaos:
  chaos = False
  changed_seating_array = deepcopy(seating_array)

  for y in range(len(seating_array)):
    for x in range(len(seating_array[y])):
      if (seating_array[y][x]=="L"):
        ## Check for adjacent seats 
        adjacent = True
        for seat in findAdjacentSeats(x,y,seating_array):
          if (seating_array[seat[1]][seat[0]] == "#"):
            adjacent = False
            continue
        if adjacent:
          changed_seating_array[y][x] = "#"
          chaos = True
          
      
      elif (seating_array[y][x] == "#"):
        adjacent_occupied = 0
        for seat in findAdjacentSeats(x,y,seating_array):
          if (seating_array[seat[1]][seat[0]] == "#"):
            adjacent_occupied +=1
        if (adjacent_occupied>=4):
          changed_seating_array[y][x] = "L"
          chaos = True
          
  seating_array = changed_seating_array


## Count occupied seats 
counter = 0
for y in range(len(seating_array)):
    for x in range(len(seating_array[y])):
      if (seating_array[y][x]=="#"):
        counter +=1
print(counter)

### PART 2 ### 
from copy import deepcopy
input = open("InputDay11.txt")
data = [value for value in input.read().splitlines()]

## Create initial array 
seating_array = []
for row in data:
  seating_row = []
  for pos in row:
    seating_row.append(pos)
  seating_array.append(seating_row)


def findAdjacentSeats(x,y,arr):
  adjacent_seats = []
  stop = 0
  incrementor = 1
  while (stop<8):
    if (x-incrementor>=0):
      adjacent_seats.append((x-incrementor,y))
    else:
      stop +=1
    if (x+incrementor<len(arr[y])):
      adjacent_seats.append((x+incrementor,y))
    else:
      stop +=1
    if (y-incrementor>=0):
      adjacent_seats.append((x,y-incrementor))
    else:
      stop +=1
    if (y+incrementor<len(arr)):
      adjacent_seats.append((x,y+incrementor))
    else:
      stop +=1
    if (x-incrementor>=0 and y-incrementor>=0):
      adjacent_seats.append((x-incrementor,y-incrementor))
    else:
      stop +=1
    if (y-incrementor>=0 and x+incrementor<len(arr[y-incrementor])):
      adjacent_seats.append((x+incrementor,y-incrementor))
    else:
      stop +=1
    if (x-incrementor>=0 and y+incrementor<len(arr)):
      adjacent_seats.append((x-incrementor,y+incrementor))
    else:
      stop +=1
    if (y+incrementor<len(arr) and x+incrementor<len(arr[y+1])):
      adjacent_seats.append((x+incrementor,y+incrementor))
    else:
      stop +=1
    
    incrementor +=1
  return adjacent_seats

## fix seats
chaos = True
while chaos:
  chaos = False
  changed_seating_array = deepcopy(seating_array)

  for y in range(len(seating_array)):
    for x in range(len(seating_array[y])):
      if (seating_array[y][x]=="L"):
        ## Check for adjacent seats 
        adjacent = True
        for seat in findAdjacentSeats(x,y,seating_array):
          if (seating_array[seat[1]][seat[0]] == "#"):
            adjacent = False
            continue
        if adjacent:
          changed_seating_array[y][x] = "#"
          chaos = True
      
      elif (seating_array[y][x] == "#"):
        adjacent_occupied = 0
        for seat in findAdjacentSeats(x,y,seating_array):
          if (seating_array[seat[1]][seat[0]] == "#"):
            adjacent_occupied +=1
        if (adjacent_occupied>=5):
          changed_seating_array[y][x] = "L"
          chaos = True
        break
  seating_array = changed_seating_array


## Count occupied seats 
counter = 0
for y in range(len(seating_array)):
    for x in range(len(seating_array[y])):
      if (seating_array[y][x]=="#"):
        counter +=1
print(counter)

"""Day 12"""

### PART 1 ###
input = open("InputDay12.txt")
data = [value for value in input.read().splitlines()]

direction = 0 ## Stands for East 
## position variables
horizontal = 0
vertical = 0 

for instruction in data:
  action = instruction[0]
  value = int(instruction[1:])
  if (action == "L"):
    direction += value
    direction = direction % 360
  elif (action == "R"):
    direction -= value
    direction = direction % 360
  
  elif (action == "N"):
    vertical += value
  elif (action == "S"):
    vertical -= value
  elif (action == "E"):
    horizontal += value
  elif (action == "W"):
    horizontal -= value
  
  elif (action == "F"):
    if (direction == 0 or direction == 360):
      horizontal += value
    elif (direction == 90):
      vertical += value
    elif (direction == 180):
      horizontal -= value
    elif (direction == 270):
      vertical -= value

print(abs(horizontal)+abs(vertical))

### PART 2 ### 
waypoint = [10,1] ## store horizontal, vertical of the waypoint 
ship = [0,0]
direction = 0 ## Stands for East 
for instruction in data:
  action = instruction[0]
  value = int(instruction[1:])
  if (action == "L"):
    if (value == 90):
      temp = waypoint[0]
      waypoint[0] = (-1*waypoint[1])
      waypoint[1] = temp
    elif (value == 180):
      waypoint[0] = (-1*waypoint[0])
      waypoint[1] = (-1*waypoint[1])
    elif (value == 270):
      temp = waypoint[0]
      waypoint[0] = waypoint[1]
      waypoint[1] = temp*-1
  elif (action == "R"):
    if (value == 90):
      temp = waypoint[0]
      waypoint[0] = waypoint[1]
      waypoint[1] = temp*-1
    elif (value == 180):
      waypoint[0] = (-1*waypoint[0])
      waypoint[1] = (-1*waypoint[1])
    elif (value == 270):
      temp = waypoint[0]
      waypoint[0] = (-1*waypoint[1])
      waypoint[1] = temp
  elif (action == "N"):
    waypoint[1] += value
  elif (action == "S"):
    waypoint[1] -= value
  elif (action == "E"):
    waypoint[0] += value
  elif (action == "W"):
    waypoint[0] -= value
  
  elif (action == "F"):
    ship[0] += waypoint[0]*value
    ship[1] += waypoint[1]*value
  

print(abs(ship[0])+abs(ship[1]))

"""Day 13"""

### PART 1 ### 
input = open("InputDay13.txt")
data = [value for value in input.read().splitlines()]

earliest = int(data[0])
bus_ids = data[1].split(sep=",")
num_ids = []
for id in bus_ids:
  if (id!="x"):
    num_ids.append(int(id))

fastest = earliest
chosen_id = 0 
for id in num_ids:
  diff = id - (earliest % id)
  if (diff<fastest):
    fastest = diff
    chosen_id = id
print(fastest*chosen_id)

### PART 2 ### 
input = open("InputDay13.txt")
data = [value for value in input.read().splitlines()]
bus_ids = data[1].split(sep=",")

bus_ids = [(int(x),ix) for ix, x in enumerate(bus_ids) if x != 'x']
skip = 1 
timestamp = 100000000000000
while bus_ids:
  for value,index in bus_ids:
    if (timestamp + index) % value == 0:
      ## Remove and change skip value because we know that the pattern of values will be repeated at every factor of skip
      bus_ids.remove((value,index))
      skip *= value
    else: 
      timestamp += skip ## Increases by the skip value because the values we have removed from bus_ids will repeat, we are now looking for the location where the next value will fit in the pattern
      break

print(timestamp)

"""Day 14"""

### PART 1 ###
from numpy import binary_repr

input = open("InputDay14.txt")
data = [value for value in input.read().splitlines()]

mem_dict = {}
mask = ""
for line in data:
  if (line[0:4] == "mask"):
    mask = line[7:]
  else: 
    ##
    start,end = line.index("["), line.index("]")
    address = int(line[start+1:end])
    val = int(line[line.index("=")+2:])
    binary_str = str(binary_repr(val))
    binary_str = binary_str.zfill(36)
    
    ## Loop through and apply the mask
    for x in range(len(mask)):
      if (mask[x]!="X"):
        b_list = list(binary_str)
        b_list[x] = mask[x]
        binary_str = "".join(b_list)

    ## Convert binary_str back to decimal value and store in address 
    val = int(binary_str,2)
    mem_dict[address] = val

## Sum up values in mem_dict 
sum = 0
for i in mem_dict.values():
  sum += i
print(sum)

### PART 2 ### 
from numpy import binary_repr
from itertools import product


mem_dict = {}
mask = ""
for line in data:
  if (line[0:4] == "mask"):
    mask = line[7:]
  else: 
    ##
    start,end = line.index("["), line.index("]")
    address = int(line[start+1:end])
    val = int(line[line.index("=")+2:])
    binary_str = str(binary_repr(address))
    binary_str = binary_str.zfill(36)
    
    ## Loop through and apply the mask
    x_count = 0
    for x in range(len(mask)):
      if (mask[x]!="0"):
        if (mask[x]=="X"):
          x_count+=1
        b_list = list(binary_str)
        b_list[x] = mask[x]
        binary_str = "".join(b_list)
    
    x_poss = product(range(2),repeat=x_count)
    
    for pos in x_poss:
    
      index = 0
      binary_str_mod = binary_str
      for y in range(len(binary_str)):
        if (binary_str[y]=="X"):
          b_list = list(binary_str_mod)
          
          b_list[y] = str(pos[index])
         
          binary_str_mod = "".join(b_list)
          index +=  1
      
      ## Convert binary_str back to decimal value and store in address
      address = int(binary_str_mod,2)
      mem_dict[address] = val
    if (x_count == 0):
      ## Convert binary_str back to decimal value and store in address 
      address = int(binary_str,2)
      mem_dict[address] = val
    
## Sum up values in mem_dict 
sum = 0
for i in mem_dict.values():
  sum += i
print(sum)

"""Day 15 (Input: 7,12,1,0,16,2)"""

### PART 1 & 2 ### 
input = [7,12,1,0,16,2]
nums_dict = {7:1,12:2,1:3,0:4,16:5,2:6}
turn = len(input) + 1
prev_number = input[len(input)-1]
first = True
while (turn<=30000000): ## USE 2020 for part 1 
  if first:
    #nums_dict[0] = turn
    prev_number = 0
    first = False
  elif (prev_number in nums_dict.keys()):
    ## update and calculate age and set age to prev number 
    age = turn - nums_dict[prev_number] -1
    nums_dict[prev_number] = turn -1 
    prev_number = age
  else:
    nums_dict[prev_number] = turn -1 
    prev_number = 0
  turn += 1 

print(prev_number)

"""Day 16"""

### PART 1 ### 
import re

input = open("InputDay16.txt")
data = [value for value in input.read().splitlines()]
# Get rules 
rules_dict = {}
for x in range(20):
  start = data[x].index(":")
  first_dash = data[x].index("-")
  or_index = data[x].index("or")
  rule_name = data[x][:start]
  temp = re.findall(r'\d+', data[x]) 
  res = list(map(int, temp))
  range_of_values = list(range(res[0],res[1]+1)) + list(range(res[2],res[3]+1))
  rules_dict[rule_name] = range_of_values

invalid_tickets = []
sum = 0
for i in range(25,len(data)):
  nums = data[i].split(",")
  
  for num in nums:
    found = False 
    for rule in rules_dict.values():
      if int(num) in rule:
        found = True
    if not found:
      invalid_tickets.append(i)
      sum+= int(num)
print(sum)

### PART 2 ### 

# Discard invalid tickets 
for ticket in sorted(invalid_tickets, reverse=True):
    del data[ticket]

## Find which fields are which in tickets 
tickets = data[25:]
tickets.append(data[22]) ## add 'my ticket' to the tickets list 

columns_list = [[] for x in range(20)]

for ticket in tickets:
  temp = re.findall(r'\d+', ticket) 
  res = list(map(int, temp))
  for i in range(len(res)):
    columns_list[i].append(res[i])

val_to_rule_dict = {}
for key in rules_dict.keys():
  val_to_rule_dict[key] = [0,[]]
counter = 0 
for column in columns_list:
  
  column_found = False
  for rule in rules_dict:
    if not column_found:
      found = True 
      for val in column:
        if val not in rules_dict[rule]:
          found = False
      if found:
        val_to_rule_dict[rule][0] +=1
        val_to_rule_dict[rule][1].append(counter)
        
  counter +=1

## With possible columns for each rule, assign rules to columns based on the number of possibilities for each rule
sorted_dict = sorted(val_to_rule_dict.items(),key=lambda x: x[1])
used = []
final_dict = {}
for rule in sorted_dict:
  for column in rule[1][1]:
    if column not in used:
      final_dict[rule[0]] = column
      used.append(column)
print(final_dict) ## final_dict gives the corresponding column for each rule
## Answer = 137*89*149*97*109*101 (I manually found the values at each column that had a rule starting with 'departure')
print(137*89*149*97*109*101)

"""Day 17"""

### PART 1 ### 
import itertools
input = open("InputDay17.txt")
data = [value for value in input.read().splitlines()]

## Read in coordinates for initial flat region
status_dict = {} #use 0 to store inactive and 1 for active
z = 0
for y in range(len(data)):
  for x in range(len(data[y])):
    if data[y][x] ==".":
      status_dict[(x,y,z)] = 0
    else:
      status_dict[(x,y,z)] = 1 

def find_neighbors(coordinate):
  neighbors = []
  directions = list(itertools.product((-1, 0, 1), repeat=3))
  for direction in directions:
    if direction != (0,0,0):
      neighbors.append((coordinate[0]+direction[0],coordinate[1]+direction[1],coordinate[2]+direction[2]))
  return neighbors

## Go through cycles
for i in range(6):
  status_dict_copy = {}
  for coord in status_dict:
    neighbors = find_neighbors(coord)
    for neighbor in neighbors:
      if status_dict.get(neighbor) == None:
        status_dict_copy[neighbor] = 0
      else:
        status_dict_copy[neighbor] = status_dict[neighbor]
  status_dict_second_copy = {}
  for coord in status_dict_copy:
    neighbors = find_neighbors(coord)
    active_count = 0 
    for neighbor in neighbors:
      if status_dict_copy.get(neighbor) != None:
        if status_dict_copy[neighbor] == 1:
          active_count += 1
    if status_dict_copy[coord] == 0:
      if active_count == 3:
        # switch to active
        status_dict_second_copy[coord] = 1
      else:
        status_dict_second_copy[coord] = 0
    else:
      if (not(active_count == 2 or active_count == 3)):
        # switch to inactive
        status_dict_second_copy[coord] = 0
      else:
        status_dict_second_copy[coord] = 1 
  status_dict = status_dict_second_copy

## Count # of actives
sum = 0
for num in status_dict.values():
  if num == 1:
    sum +=1
print(sum)

### PART 2 ### 
### PART 1 ### 
import itertools
input = open("InputDay17.txt")
data = [value for value in input.read().splitlines()]

## Read in coordinates for initial flat region
status_dict = {} #use 0 to store inactive and 1 for active
z = 0
w = 0
for y in range(len(data)):
  for x in range(len(data[y])):
    if data[y][x] ==".":
      status_dict[(x,y,z,w)] = 0
    else:
      status_dict[(x,y,z,w)] = 1 

def find_neighbors(coordinate):
  neighbors = []
  directions = list(itertools.product((-1, 0, 1), repeat=4))
  for direction in directions:
    if direction != (0,0,0,0):
      neighbors.append((coordinate[0]+direction[0],coordinate[1]+direction[1],coordinate[2]+direction[2],coordinate[3]+direction[3]))
  return neighbors

## Go through cycles
for i in range(6):
  status_dict_copy = {}
  for coord in status_dict:
    neighbors = find_neighbors(coord)
    for neighbor in neighbors:
      if status_dict.get(neighbor) == None:
        status_dict_copy[neighbor] = 0
      else:
        status_dict_copy[neighbor] = status_dict[neighbor]
  status_dict_second_copy = {}
  for coord in status_dict_copy:
    neighbors = find_neighbors(coord)
    active_count = 0 
    for neighbor in neighbors:
      if status_dict_copy.get(neighbor) != None:
        if status_dict_copy[neighbor] == 1:
          active_count += 1
    if status_dict_copy[coord] == 0:
      if active_count == 3:
        # switch to active
        status_dict_second_copy[coord] = 1
      else:
        status_dict_second_copy[coord] = 0
    else:
      if (not(active_count == 2 or active_count == 3)):
        # switch to inactive
        status_dict_second_copy[coord] = 0
      else:
        status_dict_second_copy[coord] = 1 
  status_dict = status_dict_second_copy

## Count # of actives
sum = 0
for num in status_dict.values():
  if num == 1:
    sum +=1
print(sum)

"""Day 18"""

### PART 1 ### 
input = open("InputDay18.txt")
data = [value for value in input.read().splitlines()]

def calculate(expression, start, end):
    current = start
    answer = 0
    add = True

    while current < end:

        if expression[current] == "+":
            add = True
        elif expression[current] == "*":
            add = False
        elif expression[current] == "(":

            parentheses_value = 1
            parentheses_end = current + 1
            ## find the innermost paranthesis pair and then recursively evaluate them till back at outermost 
            while parentheses_value > 0:
                if expression[parentheses_end] == ")":
                    parentheses_value -= 1
                elif expression[parentheses_end] == "(":
                    parentheses_value += 1
                parentheses_end += 1
            parentheses_end -= 1
            if add:
                answer += calculate(expression, current+1,parentheses_end)
            else:
                answer *= calculate(expression, current + 1, parentheses_end)
            current = parentheses_end
        elif expression[current] != " ":
            if add:
                answer += int(expression[current])
            else:
                answer *= int(expression[current])
        current += 1

    return answer

sum = 0
for problem in data:
  problem = problem.strip()
  sum += calculate(problem, 0, len(problem))
print(sum)

### PART 2 ### 
from functools import reduce

def calculate(expression, start, end):
    current = start
    answer = []
    current_ans = 0

    while current < end:

        if expression[current] == "*":
            answer.append(current_ans)
            current_ans = 0
        elif expression[current] == "(":
            parentheses_value = 1
            parentheses_end = current + 1
            ## find the innermost paranthesis pair and then recursively evaluate them till back at outermost 
            while parentheses_value > 0:
                if expression[parentheses_end] == ")":
                    parentheses_value -= 1
                elif expression[parentheses_end] == "(":
                    parentheses_value += 1
                parentheses_end += 1
            parentheses_end -= 1

            current_ans += calculate(expression, current+1,parentheses_end)
            current = parentheses_end

        elif expression[current] != " " and expression[current] != "+":
            current_ans += int(expression[current])

        current += 1
    answer.append(current_ans)

    return reduce((lambda x, y: x * y), answer)

## Find answer 
sum = 0
for problem in data:
  problem = problem.strip()
  sum += calculate(problem, 0, len(problem))
print(sum)

"""Day 19"""

### PART 1 ### 
 
input = open("InputDay19.txt")
data = [value for value in input.read().splitlines()]

rules = data[:135]
messages = data[136:]

rules_dict = {}
for rule in rules:
  colon_index = rule.index(":")
  rule_num = int(rule[:colon_index])
  rule_pattern = rule[colon_index+2:]
  rules_dict[rule_num] = rule_pattern


possible_messages = {}
def message_rule(num):
  if num in possible_messages.keys():
    return possible_messages[num]
  breakdown = rules_dict[num].split(" ")
  
  possible_arr = []
  finalized_arr = []
  first = True
  for element in breakdown:
    if "a" in element or "b" in element:
      possible_arr.append(element.replace('"',''))
    elif element.isnumeric():
     
      arr = message_rule(int(element))
      if first:
        for x in arr:
          possible_arr.append(x)
        first = False
      else: 
        new_arr = []
        for y in possible_arr:
          for x in arr:
            new_arr.append(y+x)
        possible_arr = []
        possible_arr = new_arr
    else:
      # |
      finalized_arr = possible_arr
      possible_arr = []
      first = True
  for z in possible_arr:
    finalized_arr.append(z)
  possible_messages[num] = finalized_arr
  return finalized_arr
  

message_rule(0)
rule_zero_counter = 0 
for message in messages:
  if message in possible_messages[0]:
    rule_zero_counter +=1
print(rule_zero_counter)

### PART 2 ### 
import regex
 
with open("InputDay19.txt") as f:
    rule_text, match_strings = f.read().split("\n\n")
 
rules = {}
for l in rule_text.split("\n"):
    ix, rule = l.split(":")
    if '"' in rule:
        rules[int(ix)] = rule.strip('" \n')
    else:
        rules[int(ix)] = [[int(p) for p in part.strip().split(" ")] for part in rule.split("|")]
 
 
def define_regexp(i):
    if isinstance(rules[i], str):
        p = rules[i]
    else:  # list of lists
        options = ["".join(f"(?&r{j})" for j in option) for option in rules[i]]
        p = "|".join(f"(?:{r})" for r in options)
    return f"(?P<r{i}>{p})"
 
 
for part in [1, 2]:
    if part == 2:
        rules.update({8: [[42], [42, 8]], 11: [[42, 31], [42, 11, 31]]})
    definitions = "(?(DEFINE)" + "".join(define_regexp(k) for k in rules.keys()) + ")"
    pattern = regex.compile(definitions + "^(?&r0)$")
    count = sum(pattern.match(s) is not None for s in match_strings.split("\n"))
    print(count)

"""Day 20"""

### PART 1 ### 
input = open("InputDay20.txt")
tiles = [value for value in input.read().split("\n\n")]
tiles.pop()


tiles_dict = {}
tiles_pattern = {}
for tile in tiles:
  num = int(tile[5:9])
  
  ## Get side patterns
  pattern = tile.split("\n")[1:] ## drop the tile number/label
  top = pattern[0]
  bottom = pattern[len(pattern)-1]
  left = ""
  right = ""
  for line in pattern:
    left += line[0]
    right += line[len(line)-1]
  tiles_pattern[num] = pattern
  tiles_dict[num] = [top,bottom,left,right] ## 0- top, 1- bottom, 2 - left , 3 - right

edge_dictionary = {}
edge_counter = {num:0 for num in tiles_dict.keys()}
for tile in tiles_dict:
  
  copied_dict = {k:tiles_dict[k] for k in tiles_dict.keys() if k != tile}
  reverse_dict = {}
  for k in copied_dict.keys():
    reverse_arr = []
    for pattern in copied_dict[k]:
      reverse_arr.append(pattern[len(pattern)::-1])
    reverse_dict[k] = reverse_arr
  
  edges = []
  t = Tile_Impl(tile)
  for square in copied_dict:
    ## Check top
    if (tiles_dict[tile][0] in copied_dict[square] or tiles_dict[tile][0] in reverse_dict[square]):
      t.top = square
      edges.append(square)
      edge_counter[tile] +=1
    ## Check bottom
    elif (tiles_dict[tile][1] in copied_dict[square] or tiles_dict[tile][1] in reverse_dict[square]):
      t.bottom = square
      edges.append(square)
      edge_counter[tile] +=1
    ## Check left
    elif (tiles_dict[tile][2] in copied_dict[square] or tiles_dict[tile][2] in reverse_dict[square]):
      t.left = square
      edges.append(square)
      edge_counter[tile] +=1
    ## Check right
    elif (tiles_dict[tile][3] in copied_dict[square] or tiles_dict[tile][3] in reverse_dict[square]):
      t.right = square
      edges.append(square)
      edge_counter[tile] +=1
  edge_dictionary[tile] = t
corners = []
for edge in edge_counter:
  if edge_counter[edge] == 2:
    corners.append(edge)

multiple = 1 
for corner in corners:
  multiple*=corner

print(multiple)

class Tile_Impl:
  def __init__(self, id_num):
    self.id = id_num
    self.top = 0
    self.bottom = 0
    self.left = 0
    self.right = 0

### PART 2 ### 
print(tiles_pattern[corners[2]])
print(tiles_pattern[edge_dictionary[corners[2]].bottom])
print(tiles_pattern)

"""Day 21"""

### PART 1 ### 
input = open("InputDay21.txt")
data = [value for value in input.read().splitlines()]

ingredients_count_dict = {}
possible_allergens = {}
for food in data:
  start = food.index("(") + len("contains") + 1
  end = food.index(")")
  foods_list = set(food[:food.index("(")-1].split(" "))
  
  allergens = food[start:end]
  allergens_list = allergens.replace(" ","").split(",")
  for ingredient in foods_list:
    ingredients_count_dict[ingredient] = ingredients_count_dict.get(ingredient, 0) + 1
  for a in allergens_list:
    if a in possible_allergens:
        possible_allergens[a] &= foods_list
    else:
        possible_allergens[a] = foods_list.copy()

dangerous = {} ## Dictionary to store the allergen (key) and dangerous ingredients in the other language (value)
while len(possible_allergens)>0:
  allergen = [a for a, i in possible_allergens.items() if len(i) == 1][0] ## Get items one at a time, when there is only one possible ingredient for that allergen
  ingredient = possible_allergens.pop(allergen)
  for a,i in possible_allergens.items():
    i -= i & ingredient ## Remove that ingredient from any other possible allergens
  dangerous[allergen] = ingredient.pop()

ingredients_to_avoid = dangerous.values()
print(sum([count for ingr,count in ingredients_count_dict.items() if ingr not in ingredients_to_avoid])) ## sum a list of the number of counts for each item that is not an ingredient

### PART 2 ### 
sorted_allergens = sorted(dangerous)
canonical_danger_str = ""
for allergen in sorted_allergens:
  canonical_danger_str += dangerous[allergen] +","
canonical_danger_str = canonical_danger_str[:len(canonical_danger_str)-1] ## get rid of last comma
print (canonical_danger_str)

"""Day 22"""

### PART 1 ### 
input = open("InputDay22.txt")
data = [value for value in input.read().split("\n\n")]
player_1 = data[0][10:].split("\n")
player_2 = data[1][10:len(data[1])-1].split("\n")

## convert to ints
player_1 = [int(num_str) for num_str in player_1]
player_2 = [int(num_str) for num_str in player_2]


while len(player_1)>0 and len(player_2) > 0:
  
  player_1_top_card = player_1.pop(0)
  player_2_top_card = player_2.pop(0)
  #print("Player 1 plays: " + str(player_1_top_card))
  #print("Player 2 plays: " + str(player_2_top_card))
  if (player_1_top_card>player_2_top_card):
    #print("Player 1 Wins")
    player_1.append(player_1_top_card)
    player_1.append(player_2_top_card)
  elif (player_1_top_card<player_2_top_card):
    #print("Player 2 Wins")
    player_2.append(player_2_top_card)
    player_2.append(player_1_top_card)
  
  # print(player_1)
  # print(player_2)
  # print("--------------NEXT ROUND----------------")


## Find multiple score for the winning player 
def calcScore(deck):
  multiple = len(deck)
  score = 0
  for card in deck:
    score += (multiple*card)
    multiple -= 1
  return score

if (len(player_1)==0):
  ## Player 2 won
  print("Player 2 Won: " + str(calcScore(player_2)))
else:
  ## Player 1 won
  print("Player 1 Won: " + str(calcScore(player_1)))

### PART 2 ### 
input = open("InputDay22.txt")
data = [value for value in input.read().split("\n\n")]
player_1 = data[0][10:].split("\n")
player_2 = data[1][10:len(data[1])-1].split("\n")

## convert to ints
player_1 = [int(num_str) for num_str in player_1]
player_2 = [int(num_str) for num_str in player_2]


def is_previous_deck(curr_deck,prev_decks):
  
  if (len(prev_decks)==0):
    return False
  for prev_deck in prev_decks:
    #print(prev_decks)
    if (len(prev_deck)==len(curr_deck)):
      is_same = True
      for x in range(len(prev_deck)):
        if (prev_deck[x]==curr_deck[x]):
          continue
        else:
          is_same = False
      if is_same:
        return True

  return False

def recursive_combat_game(player_1,player_2,player_1_prevs,player_2_prevs):
  #print("New GAME")
  while len(player_1)>0 and len(player_2) > 0:
    #print("New Round")
    #print("Player 1's deck: " + str(player_1))
    #print("Player 2's deck: " + str(player_2))
    if is_previous_deck(player_1,player_1_prevs) or is_previous_deck(player_2,player_2_prevs):
      #print("repeat, player 1 wins")
      return 1 
    
    player_1_prevs.append([val for val in player_1])
    player_2_prevs.append([val for val in player_2])

    player_1_top_card = player_1.pop(0)
    player_2_top_card = player_2.pop(0)
    #print("Player 1 plays: " + str(player_1_top_card))
    #print("Player 2 plays: " + str(player_2_top_card))

    winner = 0
    # print("player 1 len:" + str(len(player_1)))
    # print("player 2 len:" + str(len(player_2)))
    if (len(player_1)>=player_1_top_card) and (len(player_2)>=player_2_top_card):  
      ## Play a recursive game
      #print("playing a subgame")
      winner = recursive_combat_game(player_1[:player_1_top_card],player_2[:player_2_top_card],[],[])
      if winner == 1:
        #print("player 1 won the subgame")
        player_1.append(player_1_top_card)
        player_1.append(player_2_top_card)
      elif winner == 2:
        #print("player 2 won the subgame")
        player_2.append(player_2_top_card)
        player_2.append(player_1_top_card)
    else:
      ## Play the round with the normal rules
      if (player_1_top_card>player_2_top_card):
        #print("Player 1 Wins by higher card")
        player_1.append(player_1_top_card)
        player_1.append(player_2_top_card)
      elif (player_1_top_card<player_2_top_card):
        #print("Player 2 Wins by higher card")
        player_2.append(player_2_top_card)
        player_2.append(player_1_top_card)
  ## Determine winner of finished game
  if (len(player_1)==0):
    ## Player 2 won
    return 2
  else:
    ## Player 1 won
    return 1


recursive_combat_game(player_1,player_2,[],[])
#print(player_1)
#print(player_2)
## Find multiple score for the winning player 
def calcScore(deck):
  multiple = len(deck)
  score = 0
  for card in deck:
    score += (multiple*card)
    multiple -= 1
  return score

if (len(player_1)==0):
  ## Player 2 won
  print("Player 2 Won: " + str(calcScore(player_2)))
else:
  ## Player 1 won
  print("Player 1 Won: " + str(calcScore(player_1)))

"""Day 23"""

### PART 1 ### 
input = [9,1,6,4,3,8,2,7,5]

def findDestinationCup(curr_value,remaining):
  destination = 0
  looking_for = curr_value - 1
  while destination == 0:
    for element in remaining:
      if(element == looking_for):
        destination = element
    if (looking_for <= min(remaining)):
      looking_for = max(remaining)
    else:
      looking_for -= 1
  
  return destination

curr_index = 0
for move in range(100):
  # print("----MOVE " + str(move+1) + "----")
  curr_val = input[curr_index]
  # print("Current val " + str(input[curr_index]))
  # print(input)
  removed = input[curr_index+1:curr_index+4]
  if (curr_index+4>=len(input)):
    to_insert = input[0:curr_index+4-len(input)]
    for i in to_insert:
      removed.append(i)
  # print("pick up " + str(removed))
  remaining_elements = [x for x in input if x not in removed]
  destination_val = findDestinationCup(input[curr_index],remaining_elements)
  # print(remaining_elements)
  # print("destination val " + str(destination_val))
  destination_index = remaining_elements.index(destination_val)
  # print("index: " + str(destination_index))
  remaining_elements[destination_index+1:destination_index+1] = removed
  # print(remaining_elements)
  # print(" ")
  input = remaining_elements
  curr_index = input.index(curr_val)+1
  if (curr_index>=len(input)):
    curr_index = 0
#print(input)

## Print out string of numbers after 1 
one_index = input.index(1)
order_arr = input[one_index+1:] + input[:one_index]
final_str = ""
for i in order_arr:
  final_str += str(i)

print("Final " + final_str)

### PART 2 ### 
input = [9,1,6,4,3,8,2,7,5]
for i in range(10,1000001):
  input.append(i)

def findDestinationCup(curr_value,remaining):
  destination = 0
  looking_for = curr_value - 1
  while destination == 0:
    for element in remaining:
      if(element == looking_for):
        destination = element
    if (looking_for <= min(remaining)):
      looking_for = max(remaining)
    else:
      looking_for -= 1
  
  return destination

curr_index = 0
for move in range(10000000):
  if (move % 100 ==0):
    print(move)
  # print("----MOVE " + str(move+1) + "----")
  curr_val = input[curr_index]
  # print("Current val " + str(input[curr_index]))
  # print(input)
  removed = input[curr_index+1:curr_index+4]
  if (curr_index+4>=len(input)):
    to_insert = input[0:curr_index+4-len(input)]
    for i in to_insert:
      removed.append(i)
  # print("pick up " + str(removed))
  remaining_elements = [x for x in input if x not in removed]
  destination_val = findDestinationCup(input[curr_index],remaining_elements)
  # print(remaining_elements)
  # print("destination val " + str(destination_val))
  destination_index = remaining_elements.index(destination_val)
  # print("index: " + str(destination_index))
  remaining_elements[destination_index+1:destination_index+1] = removed
  # print(remaining_elements)
  # print(" ")
  input = remaining_elements
  curr_index = input.index(curr_val)+1
  if (curr_index>=len(input)):
    curr_index = 0
#print(input)

## Print out string of numbers after 1 
one_index = input.index(1)
first_cup = input[one_index+1]
second_cup = input[one_index+2]

print("Final " + str((first_cup*second_cup)))

"""Day 24"""

### PART 1 ### 
import re
input = open("InputDay24.txt")
data = [value for value in input.read().splitlines()]

tiles_dict = {}

for tile in data:
  pattern = r"(e)|(w)|(se)|(ne)|(sw)|(nw)"
  directions = [l.group() for l in re.finditer(pattern, tile)]
  #print(directions)
  coord = [0,0]
  for direction in directions:
    if direction == "se":
      coord = [coord[0],coord[1]-1]
    elif direction == "ne":
      coord = [coord[0]+1,coord[1]+1]
    elif direction == "sw":
      coord = [coord[0]-1,coord[1]-1]
    elif direction == "nw":
      coord = [coord[0],coord[1]+1]
    elif direction == "w":
      coord = [coord[0]-1,coord[1]]
    elif direction == "e":
      coord = [coord[0]+1,coord[1]]
  
  coord = tuple(coord)
  if coord in tiles_dict.keys():
    tiles_dict[coord] = not tiles_dict[coord]
  else:
    tiles_dict[coord] = True ## True means black, False means white


black_tile_counter = 0
for tile in tiles_dict:
  if tiles_dict[tile]:
    black_tile_counter += 1

print(black_tile_counter)

### PART 2 ### 
import copy
def count_adjacent(coord,t_dict):
  adjacent_locations = [(-1,-1),(-1,0),(0,1),(1,1),(1,0),(0,-1)]
  black_count = 0
  for location in adjacent_locations:
    adj = tuple(map(lambda x, y: x + y, coord, location))
    if adj in t_dict.keys():
      # check tile's color
      if t_dict[adj]:
        # if it is black
        black_count+=1
    
  return black_count

def add_adjacents(t_dict):
  adjacent_locations = [(-1,-1),(-1,0),(0,1),(1,1),(1,0),(0,-1)]
  t_dict_copy = copy.deepcopy(t_dict)
  for coord in t_dict:
    for location in adjacent_locations:
      adj = tuple(map(lambda x, y: x + y, coord, location))
      if adj not in t_dict_copy.keys():
        t_dict_copy[adj] = False
  return t_dict_copy


for i in range(100):
  tiles_dict = add_adjacents(tiles_dict)
  tiles_dict_temp = copy.deepcopy(tiles_dict)
  for tile in tiles_dict_temp:
    adj_count = count_adjacent(tile,tiles_dict_temp)
    if tiles_dict_temp[tile]:
      if adj_count == 0 or adj_count>2:
        # flip black to white
        tiles_dict[tile] = False
    else:
      if adj_count == 2:
        # flip white to black
        tiles_dict[tile] = True

black_tile_counter = 0
for tile in tiles_dict:
  if tiles_dict[tile]:
    black_tile_counter += 1

print(black_tile_counter)

"""Day 25"""

### PART 1 ### 
input = open("InputDay25.txt")
data = [int(value) for value in input.read().splitlines()]
pub_key_1 = data[0]
pub_key_2 = data[1]


def findLoopSize(subject_number, public_key):
  val = 1
  loop_num = 0
  while val != public_key:
    loop_num+=1
    val *= subject_number
    val = val % 20201227
  
  return loop_num

def findEncryptionKey(public_key,loop_size):
  val = 1
  for i in range(loop_size):
    val *= public_key
    val = val % 20201227
  return val

loop_size_1 = findLoopSize(7,pub_key_1)
encryption_key = findEncryptionKey(pub_key_2,loop_size_1)
print(encryption_key)